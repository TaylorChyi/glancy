import { promises as fs } from "node:fs";
import path from "node:path";
import { PATHS } from "../../config/shared/projectPaths.js";

const ASSETS_ROOT = PATHS.assets;
const OUTPUT_FILE = path.resolve(ASSETS_ROOT, "icon-manifest.generated.js");

const NORMALISED_SEPARATOR = "/";

const normaliseSeparator = (value) =>
  value.split(path.sep).join(NORMALISED_SEPARATOR);

const stripSvgExtension = (filename) => filename.replace(/\.svg$/i, "");

const extractVariant = (baseName) => {
  if (baseName.endsWith("-light")) {
    return { name: baseName.slice(0, -6), variant: "light" };
  }

  if (baseName.endsWith("-dark")) {
    return { name: baseName.slice(0, -5), variant: "dark" };
  }

  return { name: baseName, variant: "single" };
};

async function collectSvgFiles(rootDir) {
  const results = [];

  async function walk(currentDir) {
    const entries = await fs.readdir(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.resolve(currentDir, entry.name);
      if (entry.isDirectory()) {
        await walk(fullPath);
        continue;
      }

      if (entry.isFile() && entry.name.toLowerCase().endsWith(".svg")) {
        results.push(fullPath);
      }
    }
  }

  await walk(rootDir);
  return results;
}

const buildManifestMap = (files) => {
  const manifest = new Map();

  for (const file of files) {
    const relativePath = normaliseSeparator(path.relative(ASSETS_ROOT, file));
    const fileName = stripSvgExtension(path.basename(relativePath));
    const descriptor = extractVariant(fileName);

    if (!descriptor.name) {
      continue;
    }

    const current = manifest.get(descriptor.name) ?? new Map();
    current.set(descriptor.variant, `./${relativePath}`);
    manifest.set(descriptor.name, current);
  }

  return manifest;
};

const buildModuleSource = (manifest) => {
  const sortedEntries = Array.from(manifest.entries()).sort(([a], [b]) =>
    a.localeCompare(b),
  );

  let importIndex = 0;
  const importLines = [];
  const registryLines = [];

  for (const [name, variantMap] of sortedEntries) {
    const sortedVariants = Array.from(variantMap.entries()).sort(([a], [b]) =>
      a.localeCompare(b),
    );
    const variantAssignments = [];

    for (const [variant, relativeImportPath] of sortedVariants) {
      const urlImport = `iconAsset${importIndex++}`;
      const inlineImport = `iconAsset${importIndex++}`;
      importLines.push(`import ${urlImport} from "${relativeImportPath}";`);
      importLines.push(
        `import ${inlineImport} from "${relativeImportPath}?raw";`,
      );
      variantAssignments.push(
        `    ${variant}: Object.freeze({ url: ${urlImport}, inline: ${inlineImport} })`,
      );
    }

    registryLines.push(
      `  "${name}": Object.freeze({\n${variantAssignments.join(",\n")}\n  })`,
    );
  }

  return `${"//"} Auto-generated by ops/scripts/generate-icon-manifest.mjs. Do not edit manually.\n${importLines.join(
    "\n",
  )}\n\nconst registry = Object.freeze({\n${registryLines.join(",\n")}\n});\n\nexport default registry;\n`;
};

async function run() {
  const svgFiles = await collectSvgFiles(ASSETS_ROOT);
  const manifest = buildManifestMap(svgFiles);
  const moduleSource = buildModuleSource(manifest);
  await fs.writeFile(OUTPUT_FILE, moduleSource, "utf8");
}

run().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
