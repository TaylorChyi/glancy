# FR-052 游客模式与配额控制（Must）

> 覆盖 [SRS 12.4 “游客多维配额模型”](<../../需求说明文档/第 12 章 安全、隐私与合规.md#1241-guest-multiquota>) 与 [LLD《模块-游客鉴权与配额中间件》](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md>)，验证 Session / IP / 设备指纹 / 新建游客会话次数的组合策略，确保 `GUEST` 身份不会以生产流量充当安全演练。

## TC-GUEST-01 游客首次访问并成功查词

- **前置**
  - 选择一台从未访问过的测试设备或清理浏览器缓存，确保无 `glancy_guest_session` Cookie；记录该设备公网 IP。
  - 准备能调用 `POST /api/auth/guest`（BFF 透传到后端 `/api/v1/sessions/guest`）与 `POST /api/v1/lookup` 的调试面板或 CLI。
  - 监控 Redis 或 `guest_lookup_limit_hit` 指标，用于观察计数。
- **步骤**
  1. 调用 `POST /api/auth/guest`，请求体附带 `deviceFingerprint` 与 `client_ip`，记录响应中的 `guest_user_id`、`sessionId`、`glancy_guest_session` Cookie。
  2. 携带步骤 1 获得的 Cookie 发起一次 `POST /api/v1/lookup`，记录响应 header `X-Quota-Guest-Session-Remaining`（或等价字段）。
  3. 在 QA 面板中检查 Redis 中的 `guest:lookup:session:{sessionId}:{YYYYMMDD}` 计数被初始化为 1。
- **期望**
  - 游客会话自动创建且返回 200，响应体/Set-Cookie 中带有 `glancy_guest_session`（HttpOnly）与 `guest_user_id`。
  - 第一次查词成功返回 200，`limitType` 字段不存在，Header 显示剩余额度 20。
  - 观测指标 `guest_lookup_limit_hit` 不增量，Redis 中的会话级计数准确写入 1。
- **数据**
  - API：`POST /api/auth/guest`、`POST /api/v1/lookup`。
  - Header：`Set-Cookie: glancy_guest_session=...; HttpOnly`，`X-Quota-Guest-Session-Remaining`。
  - Redis Key 样例：`guest:lookup:session:{sessionId}:{20240520}`。
- **优先级**：P0（Must）
- **关联 UC**：[UC-G1 游客首次访问并完成第一次查词](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g1>)， [UC-01 查询词条](<../../需求说明文档/第 4 章 业务流程与用例.md#uc-01-查询词条>)
- **关联 AC**：[AC-FR-050](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#ac-fr-050>)， [GQ-01 `SESSION_LIMIT_EXCEEDED`](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#gq-01>)

## TC-GUEST-02 单 Session 连续查词 21 次

- **前置**
  - 复用 [TC-GUEST-01](#tc-guest-01-游客首次访问并成功查词) 创建的会话，确认当日计数 <20。
  - 可通过脚本批量触发 `POST /api/v1/lookup` 并抓取响应体与 Header。
- **步骤**
  1. 使用同一 `glancy_guest_session` Cookie 连续发起 21 次查词请求，记录前 20 次与第 21 次响应。
  2. 捕捉第 21 次响应的 HTTP 429 载荷，验证 `error.code=LIMIT_EXCEEDED`、`limitType=GUEST_DAILY_LOOKUP`。
  3. 查询 Redis 或监控，确认 `guest:lookup:session:{sessionId}:{date}` 计数停留在 20，`guest_lookup_limit_hit{session}` 指标增加 1。
- **期望**
  - 前 20 次请求均成功且 `X-Quota-Guest-Session-Remaining` 从 20 递减到 0。
  - 第 21 次响应 429，体内包含剩余冷却秒数与 `resetAt`，Header `X-Quota-Reset-At` 对齐本地自然日 00:00。
  - 清理 Cookie 或刷新页面后仍返回 429，直到自然日重置。
- **数据**
  - API：`POST /api/v1/lookup`。
  - Header：`X-Quota-Guest-Session-Remaining`、`X-Quota-Reset-At`。
  - 指标：`guest_lookup_limit_hit{scope="session"}`。
- **优先级**：P0（Must）
- **关联 UC**：[UC-G2 游客在日配额内多次查词](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g2>)， [UC-01 查询词条](<../../需求说明文档/第 4 章 业务流程与用例.md#uc-01-查询词条>)
- **关联 AC**：[AC-FR-050](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#ac-fr-050>)， [GQ-01 `SESSION_LIMIT_EXCEEDED`](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#gq-01>)

## TC-GUEST-03 同一 IP 触发多 Session 总量超限

- **前置**
  - 确认测试 IP 当日未用尽游客查词；准备 4–5 个不同浏览器/无痕窗口或使用脚本手动生成多个 `glancy_guest_session`。
  - QA 工具能查看 `guest:lookup:ip:{ip}:{YYYYMMDD}` 计数。
- **步骤**
  1. 在相同 IP 下并行创建 ≥3 个游客会话，每个会话发起 20 次查词，使总次数达到 60。
  2. 在任意 Session 上再次发起查词（第 61 次），记录响应体与 Header。
  3. 继续更换 Cookie、新建额外会话后再发起查词，观察是否仍然 429。
  4. 在 Redis/监控中校验 IP 级计数键已达到 60，且 `guest_lookup_limit_hit{scope="ip"}` 递增。
- **期望**
  - 第 60 次以内成功，`X-Quota-Guest-IP-Remaining` 减少至 0。
  - 第 61 次起返回 429 `LIMIT_EXCEEDED`，体内含 `limitType=GUEST_DAILY_LOOKUP`、`scope=ip`，即使更换 Session/Cookie 仍拒绝，直至自然日重置。
  - Redis 中仅 IP 维度计数达到上限，Session 计数各自保持 20；日志中记录 IP、Session、设备指纹联合信息。
- **数据**
  - API：`POST /api/auth/guest`、`POST /api/v1/lookup`。
  - Header：`X-Quota-Guest-IP-Remaining`。
  - Redis Key：`guest:lookup:ip:{client_ip}:{YYYYMMDD}`。
- **优先级**：P0（Must）
- **关联 UC**：[UC-G2 游客在日配额内多次查词](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g2>)， [UC-01 查询词条](<../../需求说明文档/第 4 章 业务流程与用例.md#uc-01-查询词条>)
- **关联 AC**：[AC-FR-050](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#ac-fr-050>)， [GQ-02 `IP_LIMIT_EXCEEDED`](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#gq-02>)

## TC-GUEST-04 同一 IP 新建游客会话超限

- **前置**
  - 使用单一公网 IP；重置环境确保无历史 `guest_session_create` 计数。
  - 工具可重复调用 `POST /api/auth/guest` 并捕捉响应。
- **步骤**
  1. 在 24 小时窗口内调用 `POST /api/auth/guest` 5 次，记录成功响应中的剩余次数提示。
  2. 第 6 次调用同一接口，观察响应状态码与错误码。
  3. 继续尝试在第 6 次之后调用 lookup API，确认无法通过新会话规避创建限额。
  4. 记录日志或监控中 `guest_session_create_limit_hit` 指标。
- **期望**
  - 前 5 次调用成功返回 200，响应体包含 `remainingGuestSessions=5→1`，Set-Cookie 始终发放。
  - 第 6 次返回 429 `GUEST_CREATION_LIMIT_EXCEEDED`，响应体含剩余冷却时间与 `resetAt`，并写入审计日志。
  - 任何新创建的 Session 在限制解除前均无法成功查词，lookup 直接 429 并提示 IP 级限制。
- **数据**
  - API：`POST /api/auth/guest`、`POST /api/v1/lookup`。
  - Header：`Retry-After`（若暴露）、`X-Guest-Session-Create-Remaining`。
  - 指标：`guest_session_create_limit_hit`。
- **优先级**：P0（Must）
- **关联 UC**：[UC-G4 游客频繁清理 Cookie / 重开页面导致 `/api/v1/sessions/guest` 超限](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g4>)
- **关联 AC**：[AC-FR-050](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#ac-fr-050>)， [GQ-03 `GUEST_CREATION_LIMIT_EXCEEDED`](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#gq-03>)

## TC-GUEST-05 清除 Cookie 后的配额持久性

- **前置**
  - 选择已经在 [TC-GUEST-02](#tc-guest-02-单-session-连续查词-21-次) 中触发 Session 限额或 [TC-GUEST-03](#tc-guest-03-同一-ip-触发多-session-总量超限) 中达到 IP 计数的浏览器。
  - 准备能清除浏览器 Cookie/LocalStorage 的工具，并保持 IP 不变。
- **步骤**
  1. 删除浏览器所有站点 Cookie、LocalStorage 与 IndexedDB。
  2. 刷新页面或重新打开浏览器，再次访问首页触发 `POST /api/auth/guest`。
  3. 拿到新的 `glancy_guest_session` Cookie 后立即发起查词，观察响应。
  4. 同时查看 Redis 中 IP 维度的计数是否仍保持在超限状态。
- **期望**
  - 清理 Cookie 后重新调用 `POST /api/auth/guest` 仍会受到 IP / 设备指纹计数影响：若 IP 级计数已满，则创建会话被拒绝或查词仍 429。
  - 查词请求不会因为新的 Session 或 Cookie 而重置 IP 级配额；响应体继续返回 `LIMIT_EXCEEDED`。
  - 监控中 `guest_lookup_limit_hit{scope="ip"}` 或 `guest_session_create_limit_hit` 无额外异常波动，仅记录继续触发次数。
- **数据**
  - API：`POST /api/auth/guest`、`POST /api/v1/lookup`。
  - 工具：浏览器 DevTools → Application → Storage 清除控件。
  - Redis Key：`guest:lookup:ip:*`、`guest:session:create:ip:*`。
- **优先级**：P1（Should）
- **关联 UC**：[UC-G4 游客频繁清理 Cookie / 重开页面导致 `/api/v1/sessions/guest` 超限](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g4>)， [UC-11 无痕查询](<../../需求说明文档/第 4 章 业务流程与用例.md#uc-11-无痕查询>)
- **关联 AC**：[AC-FR-050](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#ac-fr-050>)， [GQ-02 `IP_LIMIT_EXCEEDED`](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#gq-02>)， [GQ-03 `GUEST_CREATION_LIMIT_EXCEEDED`](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#gq-03>)

## TC-GUEST-06 不同设备指纹下的配额差异

- **前置**
  - 具备可自定义 `deviceFingerprint` 的自动化脚本，能够在同 IP 下模拟两个不同的指纹值（如浏览器 UA、分辨率、语言组合）。
  - IP 维度计数应保持未达上限，以便观察设备粒度的差异。
- **步骤**
  1. 在同一 IP 下，使用 `deviceFingerprint=A` 创建游客会话并执行 20 次查词直至 session 限额。
  2. 使用 `deviceFingerprint=B`（不同 UA/尺寸）创建另一游客会话，仅执行 1 次查词。
  3. 再次以指纹 A 调用查词，确认持续返回 `LIMIT_EXCEEDED`；以指纹 B 调用则仍然成功。
  4. 伪造缺失或为空的 `deviceFingerprint` 调用 `/api/auth/guest`，捕捉响应。
- **期望**
  - 指纹 A 在 session 限额耗尽后继续查词返回 429，而指纹 B 的会话仍在独立的配额桶中，查词成功返回 200。
  - Redis 中 `guest:lookup:device:{fingerprint}:{YYYYMMDD}` 对应 A/B 的计数分离，日志写入 `deviceFingerprint` 字段。
  - 缺失指纹的请求直接返回 400 `DEVICE_FINGERPRINT_REQUIRED`，不会创建会话也不会污染计数。
- **数据**
  - API：`POST /api/auth/guest`、`POST /api/v1/lookup`。
  - Header：`X-Device-Fingerprint`（若通过 Header 传递）或请求体 JSON 字段。
  - Redis Key：`guest:lookup:device:{fingerprint}:{YYYYMMDD}`。
- **优先级**：P1（Should）
- **关联 UC**：[UC-G2 游客在日配额内多次查词](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g2>)， [UC-G3 游客查词或 LLM 请求超出配额](<../../系统设计文档/LLD/模块-游客鉴权与配额中间件.md#uc-g3>)
- **关联 AC**：[AC-FR-050](<../../需求说明文档/第 20 章 验收标准与测试方案（UC 对齐）.md#ac-fr-050>)， [12.4.2 Device Fingerprint 验收](<../../需求说明文档/第 12 章 安全、隐私与合规.md#1242-device-fp>)
